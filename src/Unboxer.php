<?php declare(strict_types=1);

namespace Darsyn\Unboxer;

use Doctrine\Common\Collections\ArrayCollection;

class Unboxer implements UnboxerInterface
{
    public const STRINGIFY_OBJECTS = true;

    private static $knownDataMethods = [
        \DateTimeInterface::class => ['format', [\DateTimeInterface::RFC3339]],
        \DateTimeZone::class => ['getName'],
        \Throwable::class => ['getMessage'],
        \JsonSerializable::class => ['jsonSerialize'],
        ArrayCollection::class => ['toArray'],
    ];

    public function unbox($data)
    {
        return $this->convertToNativeDataType($data);
    }

    protected function convertToNativeDataType($data, array $keys = [])
    {
        if ($data === null || \is_scalar($data)) {
            return $data;
        }

        if (\is_object($data)) {
            // Autogenerated names for anonymous classes are ugly, replace with {class} just like PHP replaces anonymous
            // functions with {closure}.
            $class = \strpos(\get_class($data), '@') ? '{class}' : \get_class($data);
            $class = \trim(\strrchr($class, '\\') ?: $class, '\\');
            if ($data instanceof UnboxableInterface) {
                $keys[] = $class;
                return $this->convertToNativeDataType($data->__unbox(), $keys);
            }
            if ($interface = $this->hasKnownDataMethod($data)) {
                try {
                    $keys[] = $class;
                    return $this->convertToNativeDataType($this->callKnownDataMethod($data, $interface), $keys);
                } catch (\LogicException $e) {
                    // Careful not catch UnboxingExceptions bubbling up.
                }
            }
            if (static::STRINGIFY_OBJECTS && \method_exists($data, '__toString')) {
                $keys[] = $class;
                return $this->convertToNativeDataType($data->__toString(), $keys);
            }
            // Special case: stdClasses are just property-based associative arrays.
            if (\get_class($data) === \stdClass::class) {
                // Convert to array and let it be processed below.
                $data = (array) $data;
            }
        }

        if (\is_array($data)) {
            \array_walk($data, function (&$value, $key) use ($keys) {
                $keys[] = $key;
                // If the array is the FIRST nesting level (such as a collection), then the array values should be
                // classed as roots (a truthy value but not identical as the current value) otherwise they shouldn't.
                $value = $this->convertToNativeDataType($value, $keys);
            });
            return $data;
        }

        $message = sprintf(
            'Could not normalize to native data types, encountered type "%s" at path "%s".',
            \is_object($data) ? '\\' . \get_class($data) : \gettype($data),
            \implode('.', $keys)
        );
        throw new UnboxingException($message, $data, $keys);
    }

    /**
     * Extend this class and override this method, remembering to merge parent::getKnownDataMethods(), to expand this
     * list of known data methods. Try sticking to just native PHP classes/interfaces, or classes defined in extensions.
     * It is preferable to modify or extend a class to implement UnboxableInterface instead.
     */
    protected function getKnownDataMethods(): array
    {
        return self::$knownDataMethods;
    }

    final protected function hasKnownDataMethod($data): ?string
    {
        foreach (\array_keys($this->getKnownDataMethods()) as $interface) {
            if ($data instanceof $interface) {
                return $interface;
            }
        }
        return null;
    }

    final protected function callKnownDataMethod($data, string $interface)
    {
        $callable = $this->getKnownDataMethods()[$interface] ?? null;
        [$method, $arguments] = \array_pad($callable ?: [null], 2, []);
        if (\is_callable([$data, $method])) {
            return \call_user_func_array([$data, $method], $arguments);
        }
        // Error in program logic, attempted to call a method that doesn't exist on the object, throw exception so
        // that execution can carry on instead of using the return value.
        throw new \LogicException;
    }
}
