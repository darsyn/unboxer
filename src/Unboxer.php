<?php declare(strict_types=1);

namespace Darsyn\Unboxer;

class Unboxer implements UnboxerInterface
{
    public const STRINGIFY_OBJECTS = true;

    private static $knownDataMethods = [
        \DateTimeInterface::class => ['format', [\DateTimeInterface::RFC3339]],
        \DateTimeZone::class => ['getName'],
        \Throwable::class => ['getMessage'],
        \JsonSerializable::class => ['jsonSerialize'],
        \Doctrine\Common\Collections\Collection::class => ['toArray'],
    ];

    /**
     * Extend this class and override this method, remembering to merge parent::getKnownDataMethods(), to expand this
     * list of known data methods. Try sticking to just native PHP classes/interfaces, or classes defined in extensions.
     * It is preferable to modify or extend a class to implement UnboxableInterface instead.
     */
    protected function getKnownDataMethods(): iterable
    {
        return self::$knownDataMethods;
    }

    public function unbox($data)
    {
        return $this->convertToNativeDataType($data);
    }

    protected function convertToNativeDataType($data, array $keys = [])
    {
        if ($data === null || \is_scalar($data)) {
            return $data;
        }

        if (\is_object($data)) {
            // Autogenerated names for anonymous classes are ugly, replace with {class} just like PHP replaces anonymous
            // functions with {closure}.
            $class = \strpos(\get_class($data), '@') ? '{class}' : \get_class($data);
            $class = \trim(\strrchr($class, '\\') ?: $class, '\\');
            if ($data instanceof UnboxableInterface) {
                $keys[] = $class;
                return $this->convertToNativeDataType($data->__unbox(), $keys);
            }
            if ($this->processKnownDataTypes($data)) {
                $keys[] = $class;
                return $this->convertToNativeDataType($data, $keys);
            }
            if (static::STRINGIFY_OBJECTS && \method_exists($data, '__toString')) {
                $keys[] = $class;
                return $this->convertToNativeDataType($data->__toString(), $keys);
            }
            // Special case: stdClasses are just property-based associative arrays.
            if (\get_class($data) === \stdClass::class) {
                // Convert to array and let it be processed below.
                $data = (array) $data;
            }
        }

        if (\is_array($data)) {
            \array_walk($data, function (&$value, $key) use ($keys) {
                $keys[] = $key;
                // If the array is the FIRST nesting level (such as a collection), then the array values should be
                // classed as roots (a truthy value but not identical as the current value) otherwise they shouldn't.
                $value = $this->convertToNativeDataType($value, $keys);
            });
            return $data;
        }

        $message = sprintf(
            'Could not normalize to native data types, encountered type "%s" at path "%s".',
            \is_object($data) ? '\\' . \get_class($data) : \gettype($data),
            \implode('.', $keys)
        );
        throw new UnboxingException($message, $data, $keys);
    }

    final protected function processKnownDataTypes(&$data): bool
    {
        foreach ($this->getKnownDataMethods() as $interface => $callable) {
            if ($data instanceof $interface) {
                if ($callable instanceof \Closure) {
                    $data = $callable($data);
                    return true;
                } elseif (is_array($callable) && count($callable) >= 1) {
                    [$method, $arguments] = \array_pad($callable, 2, []);
                    if (\is_callable([$data, $method])) {
                        $data = \call_user_func_array([$data, $method], $arguments);
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
